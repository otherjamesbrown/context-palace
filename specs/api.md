# Context-Palace API

## Philosophy: SQL is the API

Context-Palace uses **direct SQL** as its primary interface. No CLI to learn, no MCP overhead, no REST server to run.

Why:
- Agents already know SQL
- Zero learning curve
- No `--help` fumbling
- No context overhead from tool definitions
- PostgreSQL is rock solid and well-documented

## How Agents Connect

Agents can connect via:

1. **psql** - `psql -h host -U user -d contextpalace -c "SELECT ..."`
2. **Any PostgreSQL library** - psycopg2, pg, node-postgres, etc.
3. **MCP postgres tool** - If available in the agent's environment

## Connection String

```
postgresql://user:password@host:5432/contextpalace
```

Store in environment variable `CONTEXT_PALACE_DB` or equivalent.

## Core Operations

See [postgres-schema.md](./postgres-schema.md) for full query examples.

### Create

```sql
-- Task
INSERT INTO shards (title, content, type, creator, owner, priority)
VALUES ('Fix bug', 'Details...', 'task', 'agent-1', 'agent-2', 1)
RETURNING id;

-- Message
INSERT INTO shards (title, content, type, creator)
VALUES ('Question about auth', 'How should we...', 'message', 'agent-1')
RETURNING id;

-- Log entry
INSERT INTO shards (title, content, type, status, creator)
VALUES ('Completed migration', 'Ran script X', 'log', 'closed', 'agent-1')
RETURNING id;
```

### Read

```sql
-- Single shard
SELECT * FROM shards WHERE id = 'cp-abc123';

-- My tasks
SELECT * FROM shards WHERE owner = 'agent-1' AND type = 'task' AND status != 'closed';

-- Unread messages
SELECT s.* FROM shards s
WHERE s.type = 'message'
  AND s.id NOT IN (SELECT shard_id FROM read_receipts WHERE agent_id = 'agent-1')
ORDER BY s.created_at;
```

### Update

```sql
-- Update content
UPDATE shards SET content = 'New content' WHERE id = 'cp-abc123';

-- Change status
UPDATE shards SET status = 'in_progress' WHERE id = 'cp-abc123';

-- Close
UPDATE shards SET status = 'closed', closed_at = NOW(), closed_reason = 'Done' WHERE id = 'cp-abc123';
```

### Delete

```sql
-- Hard delete (cascades to edges, labels, read_receipts)
DELETE FROM shards WHERE id = 'cp-abc123';
```

### Edges

```sql
-- Create relationship
INSERT INTO edges (from_id, to_id, edge_type) VALUES ('cp-a', 'cp-b', 'blocks');

-- Remove relationship
DELETE FROM edges WHERE from_id = 'cp-a' AND to_id = 'cp-b' AND edge_type = 'blocks';

-- Find what blocks a shard
SELECT s.* FROM shards s
JOIN edges e ON e.to_id = s.id
WHERE e.from_id = 'cp-abc' AND e.edge_type = 'blocks';
```

### Labels

```sql
-- Add label
INSERT INTO labels (shard_id, label) VALUES ('cp-abc', 'urgent') ON CONFLICT DO NOTHING;

-- Remove label
DELETE FROM labels WHERE shard_id = 'cp-abc' AND label = 'urgent';

-- Find by label
SELECT s.* FROM shards s
JOIN labels l ON l.shard_id = s.id
WHERE l.label = 'backend';
```

### Read Receipts

```sql
-- Mark read
INSERT INTO read_receipts (shard_id, agent_id) VALUES ('cp-abc', 'agent-1') ON CONFLICT DO NOTHING;

-- Check if read
SELECT EXISTS(SELECT 1 FROM read_receipts WHERE shard_id = 'cp-abc' AND agent_id = 'agent-1');
```

## ID Generation

IDs are auto-generated by the database:

```sql
INSERT INTO shards (title, type, creator) VALUES ('Test', 'task', 'agent-1') RETURNING id;
-- Returns: cp-a1b2c3
```

No need to generate IDs client-side.

## Conventions for Agents

1. **Always use RETURNING id** when inserting, so you get the generated ID back
2. **Use ON CONFLICT DO NOTHING** for idempotent operations (labels, read receipts)
3. **Check status before updating** if you need optimistic locking
4. **Set creator to your agent ID** so others know who made what
